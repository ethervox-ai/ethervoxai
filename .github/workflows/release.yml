name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false

env:
  BUILD_TYPE: Release

jobs:
  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.get_version.outputs.version }}
      is_prerelease: ${{ steps.check_prerelease.outputs.is_prerelease }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get version
      id: get_version
      env:
        INPUT_VERSION: "${{ github.event.inputs.version }}"
        EVENT_NAME: "${{ github.event_name }}"
      run: |
        # Use env variables (populated from expressions) inside the shell to avoid
        # direct expression interpolation in the run block.
        if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
          VERSION="$INPUT_VERSION"
        else
          VERSION=${GITHUB_REF#refs/tags/}
        fi
        # Basic whitelist: allow v prefixed semver-like strings with letters/numbers/.-_
        if ! [[ "$VERSION" =~ ^v[0-9A-Za-z._-]+$ ]]; then
          echo "Invalid or unsafe version value: $VERSION" >&2
          exit 1
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Check if pre-release
      id: check_prerelease
      env:
        VERSION_OUT: "${{ steps.get_version.outputs.version }}"
        EVENT_NAME: "${{ github.event_name }}"
        INPUT_PRERELEASE: "${{ github.event.inputs.prerelease }}"
      run: |
        # Read values from env (populated from action expressions) to avoid
        # embedding expressions directly in the run script.
        VERSION="$VERSION_OUT"
        # Re-validate VERSION here in case it's propagated from outputs
        if ! [[ "$VERSION" =~ ^v[0-9A-Za-z._-]+$ ]]; then
          echo "Invalid or unsafe version value at check_prerelease: $VERSION" >&2
          exit 1
        fi
        if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
          IS_PRERELEASE="$INPUT_PRERELEASE"
        elif [[ $VERSION =~ (alpha|beta|rc|pre) ]]; then
          IS_PRERELEASE=true
        else
          IS_PRERELEASE=false
        fi
        echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
        echo "Pre-release: $IS_PRERELEASE"

    - name: Validate version format
      run: |
        VERSION="${{ steps.get_version.outputs.version }}"
        if [[ ! $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+(\.[0-9]+)?)?$ ]]; then
          echo "Invalid version format: $VERSION"
          echo "Expected format: v1.2.3 or v1.2.3-alpha.1"
          exit 1
        fi

  build-release-assets:
    name: Build Release Assets
    needs: validate-release
    strategy:
      fail-fast: false
      matrix:
        include:
          # Desktop platforms
          - os: ubuntu-latest
            platform: linux
            arch: x64
            target: linux-x64
          - os: windows-latest
            platform: windows
            arch: x64
            target: windows-x64
          - os: macos-latest
            platform: macos
            arch: x64
            target: macos-x64
          # ARM platforms with cross-compilation
          - os: ubuntu-latest
            platform: linux
            arch: arm64
            target: linux-arm64
            cross_compile: aarch64-linux-gnu
          - os: ubuntu-latest
            platform: linux
            arch: armhf
            target: rpi-zero
            cross_compile: arm-linux-gnueabihf
          - os: ubuntu-latest
            platform: linux
            arch: arm64
            target: rpi-4
            cross_compile: aarch64-linux-gnu

    runs-on: ${{ matrix.os }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Setup Node.js for Dashboard
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        version: '9'

    - name: Setup build environment
      shell: bash
      run: |
        if [ "${{ matrix.platform }}" = "linux" ]; then
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build \
            libasound2-dev libcurl4-openssl-dev libssl-dev pkg-config
          
          # Install cross-compilation toolchains for ARM
          if [ -n "${{ matrix.cross_compile }}" ]; then
            if [ "${{ matrix.cross_compile }}" = "arm-linux-gnueabihf" ]; then
              sudo apt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf \
                binutils-arm-linux-gnueabihf crossbuild-essential-armhf
              # Add armhf architecture for cross-compiled libraries
              sudo dpkg --add-architecture armhf
              # Configure apt to use ports.ubuntu.com for armhf packages
              echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports $(lsb_release -cs) main universe" | sudo tee /etc/apt/sources.list.d/armhf-cross.list
              echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports $(lsb_release -cs)-updates main universe" | sudo tee -a /etc/apt/sources.list.d/armhf-cross.list
              echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports $(lsb_release -cs)-security main universe" | sudo tee -a /etc/apt/sources.list.d/armhf-cross.list
              sudo apt-get update
              sudo apt-get install -y libasound2-dev:armhf libcurl4-openssl-dev:armhf \
                libssl-dev:armhf
            elif [ "${{ matrix.cross_compile }}" = "aarch64-linux-gnu" ]; then
              sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \
                binutils-aarch64-linux-gnu crossbuild-essential-arm64
              # Add arm64 architecture for cross-compiled libraries
              sudo dpkg --add-architecture arm64
              # Configure apt to use ports.ubuntu.com for arm64 packages
              echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports $(lsb_release -cs) main universe" | sudo tee /etc/apt/sources.list.d/arm64-cross.list
              echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports $(lsb_release -cs)-updates main universe" | sudo tee -a /etc/apt/sources.list.d/arm64-cross.list
              echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports $(lsb_release -cs)-security main universe" | sudo tee -a /etc/apt/sources.list.d/arm64-cross.list
              sudo apt-get update
              sudo apt-get install -y libasound2-dev:arm64 libcurl4-openssl-dev:arm64 \
                libssl-dev:arm64
            fi
          fi
        elif [ "${{ matrix.platform }}" = "windows" ]; then
          choco install ninja
        elif [ "${{ matrix.platform }}" = "macos" ]; then
          brew install ninja pkg-config
        fi

    - name: Configure (Makefile)
      shell: bash
      run: |
        if [ "${{ matrix.platform }}" = "windows" ]; then
          # Windows build using CMake directly
          cmake -B build -G "Ninja" -DCMAKE_BUILD_TYPE=Release
        elif [ -n "${{ matrix.cross_compile }}" ]; then
          # Cross-compilation for ARM - use CMake directly to avoid Makefile toolchain issues
          if [ "${{ matrix.target }}" = "rpi-zero" ]; then
            # Raspberry Pi Zero (ARMv6 32-bit)
            # ARMv6 with hard-float requires ARM mode (not Thumb), so add -marm
            cmake -B build -G "Ninja" \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_SYSTEM_NAME=Linux \
              -DCMAKE_SYSTEM_PROCESSOR=arm \
              -DCMAKE_C_COMPILER=/usr/bin/${{ matrix.cross_compile }}-gcc \
              -DCMAKE_CXX_COMPILER=/usr/bin/${{ matrix.cross_compile }}-g++ \
              -DCMAKE_FIND_ROOT_PATH=/usr/${{ matrix.cross_compile }} \
              -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
              -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
              -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
              -DTARGET_PLATFORM=RPI \
              -DCMAKE_C_FLAGS="-marm -march=armv6 -mfpu=vfp -mfloat-abi=hard" \
              -DCMAKE_CXX_FLAGS="-marm -march=armv6 -mfpu=vfp -mfloat-abi=hard"
          elif [ "${{ matrix.target }}" = "rpi-4" ]; then
            # Raspberry Pi 4/5 (ARM64)
            cmake -B build -G "Ninja" \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_SYSTEM_NAME=Linux \
              -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
              -DCMAKE_C_COMPILER=/usr/bin/${{ matrix.cross_compile }}-gcc \
              -DCMAKE_CXX_COMPILER=/usr/bin/${{ matrix.cross_compile }}-g++ \
              -DCMAKE_FIND_ROOT_PATH=/usr/${{ matrix.cross_compile }} \
              -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
              -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
              -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
              -DTARGET_PLATFORM=RPI \
              -DCMAKE_C_FLAGS="-march=armv8-a+crc -mtune=cortex-a72" \
              -DCMAKE_CXX_FLAGS="-march=armv8-a+crc -mtune=cortex-a72"
          else
            # Generic ARM64
            cmake -B build -G "Ninja" \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_SYSTEM_NAME=Linux \
              -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
              -DCMAKE_C_COMPILER=/usr/bin/${{ matrix.cross_compile }}-gcc \
              -DCMAKE_CXX_COMPILER=/usr/bin/${{ matrix.cross_compile }}-g++ \
              -DCMAKE_FIND_ROOT_PATH=/usr/${{ matrix.cross_compile }} \
              -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
              -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
              -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY
          fi
        else
          # Native build - uppercase the platform name for CMake
          PLATFORM_UPPER=$(echo "${{ matrix.platform }}" | tr '[:lower:]' '[:upper:]')
          cmake -B build -G "Ninja" \
            -DCMAKE_BUILD_TYPE=Release \
            -DTARGET_PLATFORM=${PLATFORM_UPPER}
        fi

    - name: Build (Makefile)
      shell: bash
      run: |
        # All platforms now use cmake --build
        cmake --build build --config Release

    - name: Create distribution package
      shell: bash
      run: |
        cmake --build build --target package
        
        # Create release directory
        mkdir -p release-${{ matrix.target }}
        
        # Extract the CPack-generated tarball instead of copying individual files
        if [ "${{ matrix.platform }}" = "windows" ]; then
          # For Windows, look for the generated package
          if [ -f build/EthervoxAI-*-win64.zip ]; then
            unzip -q build/EthervoxAI-*-win64.zip -d release-${{ matrix.target }}/
          elif [ -f build/*.zip ]; then
            unzip -q build/*.zip -d release-${{ matrix.target }}/
          fi
        else
          # For Linux/macOS, extract the tarball
          if [ -f build/EthervoxAI-*-Linux.tar.gz ]; then
            tar -xzf build/EthervoxAI-*-Linux.tar.gz -C release-${{ matrix.target }}/
          elif [ -f build/EthervoxAI-*-Darwin.tar.gz ]; then
            tar -xzf build/EthervoxAI-*-Darwin.tar.gz -C release-${{ matrix.target }}/
          elif [ -f build/*.tar.gz ]; then
            tar -xzf build/*.tar.gz -C release-${{ matrix.target }}/
          fi
        fi
        
        # Add documentation if not already included
        cp README.md CONTRIBUTING.md LICENSE release-${{ matrix.target }}/ 2>/dev/null || true
        
        # Copy platform-specific files
        if [[ "${{ matrix.target }}" == rpi-* ]]; then
          echo "# Raspberry Pi Installation" > release-${{ matrix.target }}/INSTALL.md
          echo "" >> release-${{ matrix.target }}/INSTALL.md
          echo "This build is optimized for ${{ matrix.target }}" >> release-${{ matrix.target }}/INSTALL.md
          echo "See README.md for detailed installation instructions." >> release-${{ matrix.target }}/INSTALL.md
        fi
        
        # Create final archive
        if [ "${{ matrix.platform }}" = "windows" ]; then
          7z a ethervoxai-${{ needs.validate-release.outputs.version }}-${{ matrix.target }}.zip release-${{ matrix.target }}/*
        else
          tar -czf ethervoxai-${{ needs.validate-release.outputs.version }}-${{ matrix.target }}.tar.gz -C release-${{ matrix.target }} .
        fi

    - name: Upload release asset
      uses: actions/upload-artifact@v4
      with:
        name: release-${{ matrix.target }}
        path: |
          *.zip
          *.tar.gz
        retention-days: 1

  build-esp32-release:
    name: Build ESP32 Release
    needs: validate-release
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        target: ['esp32', 'esp32s2', 'esp32s3', 'esp32c3', 'esp32c6']

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Install ESP-IDF
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
        mkdir -p ~/esp
        cd ~/esp
        if [ ! -d "esp-idf" ]; then
          git clone -b v5.1.2 --recursive https://github.com/espressif/esp-idf.git
          cd esp-idf
          ./install.sh ${{ matrix.target }}
        fi

    - name: Build ESP32 firmware
      shell: bash
      run: |
        . ~/esp/esp-idf/export.sh
        cd esp32-project
        idf.py set-target ${{ matrix.target }}
        idf.py build

    - name: Package ESP32 release
      shell: bash
      run: |
        mkdir -p esp32-release-${{ matrix.target }}
        cd esp32-project/build
        
        # Copy firmware files
        cp ethervoxai.bin ../../esp32-release-${{ matrix.target }}/
        cp ethervoxai.elf ../../esp32-release-${{ matrix.target }}/
        cp bootloader/bootloader.bin ../../esp32-release-${{ matrix.target }}/
        cp partition_table/partition-table.bin ../../esp32-release-${{ matrix.target }}/
        
        # Copy configuration files if they exist
        [ -f ../partitions.csv ] && cp ../partitions.csv ../../esp32-release-${{ matrix.target }}/ || echo "partitions.csv not found, skipping"
        [ -f ../sdkconfig ] && cp ../sdkconfig ../../esp32-release-${{ matrix.target }}/ || echo "sdkconfig not found, skipping"
        [ -f sdkconfig ] && cp sdkconfig ../../esp32-release-${{ matrix.target }}/ || echo "build/sdkconfig not found, skipping"
        
        # Create flash script
        cd ../../esp32-release-${{ matrix.target }}
        cat > flash.sh << 'EOF'
        #!/bin/bash
        # ESP32 Flash Script
        # Usage: ./flash.sh [port]
        PORT=${1:-/dev/ttyUSB0}
        
        esptool.py --chip ${{ matrix.target }} --port $PORT --baud 460800 write_flash -z \
          --flash_mode dio --flash_freq 40m --flash_size detect \
          0x1000 bootloader.bin \
          0x8000 partition-table.bin \
          0x10000 ethervoxai.bin
        EOF
        chmod +x flash.sh
        
        # Create Windows flash script
        cat > flash.bat << 'EOF'
        @echo off
        REM ESP32 Flash Script for Windows
        REM Usage: flash.bat [COM port]
        set PORT=%1
        if "%PORT%"=="" set PORT=COM3
        
        esptool.py --chip ${{ matrix.target }} --port %PORT% --baud 460800 write_flash -z ^
          --flash_mode dio --flash_freq 40m --flash_size detect ^
          0x1000 bootloader.bin ^
          0x8000 partition-table.bin ^
          0x10000 ethervoxai.bin
        EOF
        
        # Copy documentation
        cp ../README.md ../LICENSE .
        echo "# ESP32 ${{ matrix.target }} Firmware" > README-ESP32.md
        echo "" >> README-ESP32.md
        echo "Version: ${{ needs.validate-release.outputs.version }}" >> README-ESP32.md
        echo "Target: ${{ matrix.target }}" >> README-ESP32.md
        echo "Build Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> README-ESP32.md
        echo "" >> README-ESP32.md
        echo "## Flashing Instructions" >> README-ESP32.md
        echo "" >> README-ESP32.md
        echo "### Linux/macOS:" >> README-ESP32.md
        echo '```bash' >> README-ESP32.md
        echo "./flash.sh /dev/ttyUSB0" >> README-ESP32.md
        echo '```' >> README-ESP32.md
        echo "" >> README-ESP32.md
        echo "### Windows:" >> README-ESP32.md
        echo '```cmd' >> README-ESP32.md
        echo "flash.bat COM3" >> README-ESP32.md
        echo '```' >> README-ESP32.md
        
        # Create archive
        cd ..
        tar -czf ethervoxai-esp32-${{ matrix.target }}-${{ needs.validate-release.outputs.version }}.tar.gz esp32-release-${{ matrix.target }}/

    - name: Upload ESP32 release asset
      uses: actions/upload-artifact@v4
      with:
        name: release-esp32-${{ matrix.target }}
        path: "*.tar.gz"
        retention-days: 1

  create-release:
    name: Create GitHub Release
    needs: [validate-release, build-release-assets, build-esp32-release]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: release-assets/

    - name: Generate release notes
      id: release_notes
      run: |
        VERSION="${{ needs.validate-release.outputs.version }}"
        echo "Generating release notes for $VERSION"
        
        # Get the previous tag for changelog generation
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        
        # Create release notes with auto-generated changelog
        cat > release-notes.md << EOF
        # EtherVoxAI $VERSION
        
        ## What's Changed
        
        EOF
        
        # Generate changelog from commits if previous tag exists
        if [[ -n "$PREVIOUS_TAG" ]]; then
          echo "### Changes since $PREVIOUS_TAG" >> release-notes.md
          echo "" >> release-notes.md
          
          # Get commits between tags, categorize them
          git log $PREVIOUS_TAG..HEAD --oneline --format="format:%s" | while read -r commit; do
            if [[ $commit =~ ^feat(\(.*\))?:.*|^add.*|^implement.* ]]; then
              echo "- âœ¨ $commit" >> release-notes.md
            elif [[ $commit =~ ^fix(\(.*\))?:.*|^bug.*|^resolve.* ]]; then
              echo "- ðŸ› $commit" >> release-notes.md
            elif [[ $commit =~ ^docs(\(.*\))?:.*|^update.*README|^improve.*docs ]]; then
              echo "- ðŸ“š $commit" >> release-notes.md
            elif [[ $commit =~ ^perf(\(.*\))?:.*|^optimize.*|^improve.*performance ]]; then
              echo "- âš¡ $commit" >> release-notes.md
            elif [[ $commit =~ ^refactor(\(.*\))?:.*|^restructure.*|^cleanup.* ]]; then
              echo "- â™»ï¸ $commit" >> release-notes.md
            elif [[ $commit =~ ^test(\(.*\))?:.*|^add.*test|^update.*test ]]; then
              echo "- ðŸ§ª $commit" >> release-notes.md
            elif [[ $commit =~ ^ci(\(.*\))?:.*|^github.*action|^workflow.* ]]; then
              echo "- ðŸ”§ $commit" >> release-notes.md
            else
              echo "- ðŸ“ $commit" >> release-notes.md
            fi
          done
          
          echo "" >> release-notes.md
        fi
        
        cat >> release-notes.md << EOF
        
        ## Platform Support
        
        This release includes builds for the following platforms:
        
        ### Desktop Platforms
        - **Windows x64**: Full-featured build with dashboard
        - **Linux x64**: Full-featured build with dashboard
        - **macOS x64**: Full-featured build with dashboard
        
        ### ARM Platforms (Cross-compiled)
        - **Linux ARM64**: Optimized for 64-bit ARM systems
        - **Raspberry Pi Zero**: Lightweight build for Pi Zero/Zero 2 W (ARMv6/ARMv7)
        - **Raspberry Pi 4/5**: Full-featured build for Pi 4/5 series (ARM64)
        
        ### Embedded Platforms
        - **ESP32**: Firmware for ESP32 DevKits
        - **ESP32-S2**: Firmware for ESP32-S2 modules
        - **ESP32-S3**: Firmware for ESP32-S3 with advanced features
        - **ESP32-C3**: Compact firmware for ESP32-C3 RISC-V
        - **ESP32-C6**: Firmware for ESP32-C6 with Wi-Fi 6
        
        ## Installation
        
        1. Download the appropriate package for your platform
        2. Extract the archive
        3. Follow the platform-specific installation instructions in the README
        
        ## ESP32 Flashing
        
        For ESP32 devices, use the included flash scripts:
        - Linux/macOS: \`./flash.sh /dev/ttyUSB0\`
        - Windows: \`flash.bat COM3\`
        
        ## Support
        
        - Documentation: See README.md in each package
        - Issues: Report on GitHub Issues
        - Discussions: GitHub Discussions
        
        EOF
        
        # Add changelog if exists
        if [ -f CHANGELOG.md ]; then
          echo "## Changelog" >> release-notes.md
          echo "" >> release-notes.md
          awk "/^## \[$VERSION\]/,/^## \[/" CHANGELOG.md | head -n -1 >> release-notes.md
        fi

    - name: Collect release assets
      run: |
        mkdir -p final-release/
        find release-assets/ -name "*.zip" -o -name "*.tar.gz" | while read file; do
          cp "$file" final-release/
        done
        
        echo "Release assets:"
        ls -la final-release/

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.validate-release.outputs.version }}
        name: EtherVoxAI ${{ needs.validate-release.outputs.version }}
        body_path: release-notes.md
        prerelease: ${{ needs.validate-release.outputs.is_prerelease }}
        files: final-release/*
        generate_release_notes: true
        make_latest: ${{ needs.validate-release.outputs.is_prerelease == 'false' }}

  update-documentation:
    name: Update Release Documentation
    needs: [create-release]
    runs-on: ubuntu-latest
    if: needs.validate-release.outputs.is_prerelease == 'false'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Update version references
      run: |
        VERSION="${{ needs.validate-release.outputs.version }}"
        
        # Update README badges if they exist
        if grep -q "version-" README.md; then
          sed -i "s/version-[^-]*-/version-${VERSION#v}-/" README.md
        fi
        
        # Update documentation version references
        find docs/ -name "*.md" -exec sed -i "s/v[0-9]\+\.[0-9]\+\.[0-9]\+/$VERSION/g" {} \; 2>/dev/null || true

    - name: Commit documentation updates
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if git diff --quiet; then
          echo "No documentation changes needed"
        else
          git add -A
          git commit -m "docs: update version references to ${{ needs.validate-release.outputs.version }}"
          git push
        fi